import { Product } from '../models';
import multer from 'multer';
import path from 'path';
import createError from 'http-errors';
import fs from 'fs';
import Joi from 'joi';
import { productDTO, userDTO } from '../dtos';
import { nanoid } from 'nanoid';
import { productSchema } from '../validators';

/* Image storage with multer */
const storage = multer.diskStorage({
  /* Upload images in uploads folder */
  destination: (req, file, cb) => cb(null, 'uploads/'),
  filename: (req, file, cb) => {
    const uniqueFileName = `${Date.now()}-${Math.round(Math.random() * 1e10)}-${nanoid(10)}${path.extname(file.originalname)}`;
    console.log(uniqueFileName);
    // 1647833402413-506306544-IRFa-VaY2b.png
    cb(null, uniqueFileName);
  },
});

/* Multer will handle multipart data */
const handleMultipartData = multer({
  storage,
  fileFilter: function (req, file, callback) {
    var ext = path.extname(file.originalname);
    if (ext !== '.png' && ext !== '.jpg' && ext !== '.gif' && ext !== '.jpeg') {
      return callback(new Error('Only Images are Allowed !!'));
    }
    callback(null, true);
  },
  limits: {
    fileSize: 1000000 * 5, // 5 MB
  },
}).single('image'); // single image, fieldname : image

const productController = {
  /* Controller for admin to add an item to store */
  async add(req, res, next) {
    // Multipart form data
    handleMultipartData(req, res, async (err) => {
      if (err) {
        return next(createError.InternalServerError());
      }
      // If image is not present (Image must be present)
      if (req.file === undefined) {
        return next(createError.UnprocessableEntity());
      }
      // Validating the incoming request schema
      const { error } = productSchema.validate(req.body);
      // Getting the filePath generated by multer
      const filePath = req.file.path;
      if (error) {
        /* If schema validation is failed,
           delete the uploaded file
        */
        fs.unlink(`${appRoot}/${filePath}`, (err) => {
          if (err) {
            console.log(err);
            return next(createError.InternalServerError());
          }
        });
        return next(createError.UnprocessableEntity());
      }
      const { name, price } = req.body;
      let newProduct;
      try {
        /* Insert the Product into DB */
        newProduct = await Product.create({ name, price, image: filePath, addedBy: req.user._id });
        // Populate the addedBy field from User DB
        Product.populate(newProduct, { path: 'addedBy' }, function (err, newProduct) {
          if (err) {
            throw new Error('Unable to Populate Product');
          }
          newProduct = new productDTO(newProduct);
          // Return the added Product as success response
          res.status(201).json(newProduct);
        });
      } catch (error) {
        /* If product is unable to insert into DB
           then also remove the uploaded orphan image
        */
        fs.unlink(`${appRoot}/${filePath}`, (err) => {
          if (err) {
            console.log(err);
            return next(createError.InternalServerError());
          }
        });
        return next(createError.InternalServerError());
      }
    });
  },
  /* Controller for admin to update an item in store */
  async update(req, res, next) {
    // Multipart form data
    handleMultipartData(req, res, async (err) => {
      if (err) {
        return next(createError.InternalServerError());
      }
      let filePath;
      console.log(req.file);
      // If image exists in request then initialize filePath
      if (req.file) {
        filePath = req.file.path;
      }
      // Validating the incoming request schema
      const { error } = productSchema.validate(req.body);
      if (error) {
        /* If schema validation is failed,
           delete the uploaded file
        */
        if (req.file) {
          fs.unlink(`${appRoot}/${filePath}`, (err) => {
            if (err) {
              return next(createError.InternalServerError());
            }
          });
        }
        return next(createError.UnprocessableEntity());
      }
      const { name, price } = req.body;
      let updatedProduct;
      try {
        /* Find the old product for further reference to the old product */
        const oldProduct = await Product.findById(req.params.id);
        /* Find and Update the Product and return the updated value */
        updatedProduct = await Product.findOneAndUpdate({ _id: req.params.id }, { name, price, ...(req.file && { image: filePath }) }, { new: true });
        // Populate the addedBy field from User DB
        Product.populate(updatedProduct, { path: 'addedBy' }, function (err, updatedProduct) {
          if (err) {
            throw new Error('Unable to Populate Product');
          }
          // If product is updated with new image, then delete the old image
          if (req.file) {
            // ._doc bypasses the getter and fetches the actual value from DB
            fs.unlink(`${appRoot}/${oldProduct._doc.image}`, (err) => {
              // If old image cannot be removed, ignore and move forward
              if (err) {
              }
            });
          }
          updatedProduct = new productDTO(updatedProduct);
          // Return the updated Product as success response
          res.status(201).json(updatedProduct);
        });
      } catch (error) {
        return next(createError.InternalServerError());
      }
    });
  },
  /* Controller for admin to delete an item in store */
  async delete(req, res, next) {
    try {
      // Find and remove the Product
      let deletedProduct = await Product.findOneAndRemove({ _id: req.params.id });
      // If the Product was not found throw an Error
      if (!deletedProduct) {
        return next(new Error('Nothing to Delete'));
      }
      // Delete the image of the deleted Product
      // ._doc bypasses the getter and fetches the actual value from DB
      const imagePath = deletedProduct._doc.image;
      fs.unlink(`${appRoot}/${imagePath}`, (err) => {
        // If image cannot be removed, ignore and move forward
        if (err) {
        }
      });
      // Populate the addedBy field from User DB
      Product.populate(deletedProduct, { path: 'addedBy' }, function (err, deletedProduct) {
        if (err) {
          throw new Error('Unable to Populate Product');
        }
        deletedProduct = new productDTO(deletedProduct);
        // Return the deleted Product as success response
        res.status(201).json(deletedProduct);
      });
    } catch (err) {
      return next(createError.InternalServerError());
    }
  },
  /* Controller to show all the items in the store */
  async showAll(req, res, next) {
    res.json(res.paginatedResults);
  },
  /* Controller to show a single item in the store by id */
  async singleProduct(req, res, next) {
    try {
      let product = await Product.findOne({ _id: req.params.id }).populate('addedBy');
      product = new productDTO(product);
      // Return the the Product as success response
      res.json(product);
    } catch (err) {
      return next(createError.InternalServerError());
    }
  },
};

export default productController;
